Node.js is a server-side JavaScript platform. Introduced by Ryan Dahl in 2009.

At a high level, it is comprised of 3 building blocks:

1) libuv:
A high performance, cross-platform evented I/O library.
Allows to replace or abstract away a number of UNIX-only libraries.
Lib UV was built as a part of porting Node.js to the Windows environment.


2) V8
Google's JS engine, the same engine found in Chrome browser.
The Node team makes every effort to leverage V8 out of the box within Node., which makes it easier to include updated versions V8 at every release.

3) Custom JS and C++ code developed specifically for Node.

A tool called NVM allows you to have multiple versions installed and switch between them. In 2012, it waqs available for Linux and Mac only. Maybe there is a Windows versions now, maybe...

Cloud9 IDE is pretty cool for developing Node apps, even the free version is quite enough.

---- Node's Event Loop ----

One key feature Node brings from the browser to the server-side is the event loop. In the browser, the event loop constantly listens for DOM events such as clicks and key presses.

Similarly, Node's event loop is listening for events on the server side. These can be externally generated such as HTTP requests or TCP connections, or they can be timers and other internal events generated by your Node app itself.

Node itself doesn't pause and wait for any requests to complete. It simply continues to react to events as they arrive. It is a non-blocking, event driven approach. It doesn't get blocked while waiting for a response and can serve further requests. This non-blocking approach is fundamental to Node and differentiates it from the more traditional server-side programming model that requires to manage multiple threads to achieve this type of concurrency.


---- Node Conventions for Writing Async Code ----

Typical approach:

var conn = getDbConnection(connectionString);
var stmt = conn.getStatement();
var results = stmt.executeQuery(sqlQuery);
for (var i = 0; i < results.length; i++){
	// print results[i]
}

An async, non-blocking approach:

getDbConnection(connectionString, function(err, conn){
	conn.createStatement(function(err, stmt){
		var results = stmt.executeQuery(sqlQuery);
		results.on('row', function(result){
			// print result
		});
	});
});

getDbConnection takes two parameters, the second one is a function. "Get a connection to the DB, and once you have it, call this function and pass it the connection you just created". By doing this, we leave Node free to do other work while waiting for the connection to be established.
createStatement is written similarly. These two functions are examples of using callbacks, code that will run asyncly.

executeQuery function returns a value, which is a special object called "event emitter". We are telling Node to invoke a function when each row is emitted by the results object.

Some conventions:

var handleResults = function(err, results)
{ // if error is undefined or falsy
  // do something with the results
};
getStuff(regularInputParam, handleResults);

handleResults is the callback function. It is the last parameter in async func call.

For simple callbacks or the ones that are used only once, instead of a named function, you might use a simple anonymous inline functions.

getStuff(regularInputParam, function(err, results)
{ // if error is undefined or falsy
  // do something with the results
});

Anonymous function also benefit from JS's use of closures:

someOtherFunc(function(err, stuffToGet){
	var foo = 23;
	getStuff(regularInputParam, function(err, results)
	{ // if error is undefined or falsy
	  // do something with the results and foo
	});
});

---- Modules, require() and NPM ----

Modules bring external functionality to your app.

var foo = require('foo'); // Naming convention: camelcase starting with lowercase because it exports fields and functions
var Bar = require('bar'); // Naming convention: camelcase starting with uppercase because it needs to be instantiated with "new"

var f = 2 + foo.alpha; // exports variables
var b = foo.beta() * 3; // exports functions

var bar = new Bar(); // needs to be instantiated


There are 3 main source sof Node modules.

1) Built-in modules
Some simply work out of the box (setTimeout, setInterval, etc.) which are in Node's global namespace, some need to be require()'d.
var fs = require('fs'); // to access the file system
http (http requests and all)
crypto (cryptographic stuff)
os (attributes of the underlying OS)

2) Your project files
Each .js file is its own module
A great way to modularize your app's code
Each file is require()'d with file system-like semantics:
var data = require('./data'); // require data.js in same directory
var foo = require('./other/foo'); // require foo.js in a subdirectory
var bar = require('../lib/bar'); // require bar.js from some other directory
Note the "./" is always required. .js suffix is omitted.

Variables are marked for export via module.exports, so they become available at other files.
one.js:

var count = 2;
var doIt = function(i, callback){
	// do some stuff, invoke callback...
};

module.exports.doIt = doIt;
module.exports.foo = 'bar';

two.js:

var one = require('./one');
one.doIt(23, function(err, result) {
	console.log(result);
});
console.log(one.foo); // 'bar'
// console.log(one.count) -> doesn't work as count is not exported

3) Third party modules via NPM (Node Package Manager) registry
Install via "npm install module_name" into node_modules folder
Are require()'d with simple string identifiers, similar to built-in modules
	var request = require('request')
You can go down deep and pull out a single file from a module (e.g., require('azure/lib/services/blob/models/blobresult')) but his should be done with extreme care. You may introduce a coupling that the module author did not intend.

Some modules provide command line utilities (e.g., express, mocha, azure-cli). You should install them globally since their scope is beyong one single application:
"npm install -g module_name"



---- EVENTS and STREAMS ----

In addition to callbacks, Node provides another way to create async non-blocking code.

Callback:

getThem(param, function(error, items){
	// check for error
	// operate on array of items
});

Events:

var results = getThem(param);

results.on('item', function(i){
	// do something with this one item
});

results.on('done', function(){
	// no more items
});

results.on('error', function(err){
	// react to error
});

Callbacks:
1) One request, one reply.
2) No results until all results (this also causes all items to be accumulated in memory)
3) Either error or results

Events:
1) Publish/subscribe approach. "On" function can be invoked repeatedly to provide multiple functions to invoke on events (in effect, subscribing to events)
2) Act on results as they arrive. Functions associated with 'item' event will be invoked for each item.
3) Partial results before error

Node's EventEmitter class:

Subscriber:
emitter.on(event, listener);

Publisher:
emitter.emit(event, [args]);

The "event" can be any string.
An event can be emitted with 0 or more arguments. [args] get passed to any functions that subscribe to those events.

Two common patterns for using EventEmitters in Node:
1) As a return value from a function call (like in the examples above)
2) Objects extend EventEmitters and emit events themselves in addition to providing some other functionality


---- Readable and Writable Streams, the Pipe function ----

Streams are instances of () and extensions to EventEmitter with an agreed upon interface.
They are a unified abstraction to manage data flow, including:
Network traffic (http requests and responses, tcp sockets), file I/O, stdin/stdout/stderr, and more...
A stream is either a ReadableStream or a WritableStream, or both.
A ReadableStream can be pipe()'d to a WritableStream.
Node applies "backpressure" to cope with cases where a ReadableStream is consumed faster than the WritableStream it is being pipe()'d to.

Streams come with a series of properties, functions and events, but their real power is in the pipe function.

---- ACCESSING THE LOCAL SYSTEM ----

1) Node's "process" object

The "process" object allows you to manage your Node application's own process or other processes. It provides a collection of streams (stdin, stdout, stderr), attributes of the current process (process.env, process.argv, process.pid, process.title, process.optime(), process.memoryUsage(), process.cwd (current working directory), etc...), process-related actions (.abort(), .kill(), .chdir(), etc... (Note that most of these actions can be applied to the current process. "kill", however, takes in a process id and can be used to kill other processes on the system)).
The "process" object is an instance of EventEmitter. It emits an "exit" event when the process is about to exit. Also, emit some POSIX event such as SIGINT, etc...

2) Interacting with the file system

In Node, interacting with the file system is done via the built-in "fs" module. Most function are wrappers around POSIX functions and have both async and sync versions.
"fs" also provides some stream oriented functions:

fs.createReadStream() - used to open and read a file, returns an fs.ReadStream
fs.createWriteStream() - used to open and write to a file, returns an fs.WriteStream

We can also wathc a file or directory for changes:

fs.watch() - returns an fs.FSWatcher (an EventEmitter)
"change" event: emitted when a file changes, includes the type of change and the filename that changed
"error" event: emitted when an error occurs

3) Buffers

JS has difficulty dealing with binary data but networking and the file system require it. The Buffer class provides a raw memory allocation for dealing with binary data directly.
Buffers can be converted to/from strings by providing an encoding (ascii, utf8 (default), utf16le, base64, binary, hex, etc...).
Return value from file read operations is a buffer object, so we need to toString() them to get the actual value (see the fs examples in 4-local-system).

4) "os" module

Provides function to get info about the operating system your Node app is running on (tmpDir(), hostname(), type(), platform(), totalmem(), freemem(), cpus(), uptime(), etc...)
os.EOL gives the appropriate end of line marker for the operating system.

---- INTERACTING WITH THE WEB ----

We can use the http module, which is included in Node, to make requests of other websites.

var req = http.request(options, function(response){
	// process callback
});

"req" here is an instance of a http.ClientRequest, which is a writable stream.
"response" is an instance of a http.ClientResponse, which is a readable stream.
This callback is an example of when Node doesn't follow its own conventions since the first parameter is not an error indicator.

"options" can be one of the following:
1) A URL string
2) An object specifying values for host, port, method, path, headers, auth, etc...

The return value is a ClientRequest, which is a writable stream that can be written/pipe()'d to for POST requests.

The ClientResponse object is provided via either callback (shown above) or as a "response" event on the request object. So if you don't pass in a parameter to the callback function, you can still get the response by using the event emitter.

If all you want is a simple GET request, Node provides a simplified interface with http.get().

-- Building a Web Server in Node --

var http = require('http');

var server = http.createServer(function(req, res) {
	// process request
});
server.listen(port, [host]);

The createServer function is passed a single parameter (the callback to be invoked each time a request is received by the web server).

Each request is provided via either callback (as shown above) or as a "request" event on the server object, so if you don't have a callback function, you can still process requests by listening to the "request" event on the server object.

Even if the server object is created, it will not begin accepting HTTP requests until the "listen" function is called.

Callback paramaters: "req" above is an instance of a http.ServerRequest (a readable stream) and "res" above is an instance of a http.ServerResponse (a writable stream)

Support for SSL is provided by a similar but separate module called "https", so you can call https.createServer().

-- Real-time Interaction with Socket.io --

Socket.IO provides an sbstraction for various method used to maintain an active connection between a browser and a server. It'll use web sockets when they are supported, and transparently fall back to several other techniques when sockets are not available (e.g., due to firewalls or browser limitations).
In the case of Node.js, Socket.IO provides an interface for performing these socket-based communications on both the server and the browser.

In Node, we 'll simply use the socket.io module (require('socket.io')).

---- TESTING AND DEBUGGING ----

- Basic testing with the "assert" module
- More advanced stuff with Mocha and script.js

The "assert" module comes with Node, but must be required by the app. It can:
1) test for (in)equality between expected and actual values
2) test whether a block of code throws (or does not throw) an exception
3) test for truthiness of a value
4) test whether the "error" was passed to a callback

Each assertion can contain a message to output on failure.

-- Testing with Mocha and should.js --

A Node app of any complexity will quickly outgrow the built-in "assert" module's capabilities, so there are a lot of testing frameworks out there and one of the most popular ones is Mocha.

It is common to see Mocha paired with should.js, which provides a rich assertion syntax.

Mocha:

1) Runs tests serially (both async and sync tests)
2) Test cases are organised into test suites
3) Includes before(), after(), beforeEach(), afterEach()
4) Supports pending (a test that has been stubbed out but not yet implemented), exclusive, inclusive tests
5) Captures test duration, flagging tests that are slow
6) Can watch a directory and re-run the tests each time a file changes
7) Supports multiple interfaces (TDD, BDD, etc...) and output rendering

should.js:

Extends Node's "assert" module with BDD style assertions:
should.exist(user);
user.should.have.property('name', 'cem');
user.should.have.property('items').with.lengthOf(4);
user.hebele.should.equal(foo); // can assert properties of objects directly

---- SCALING YOUR NODE APPLICATION ----

One criticism against Node app is they don't handle CPU intensive tests well. If a single task is using up a lot of CPU time, this will block the event loop and prevent other things from being done.

One solution is to use child processes. A CUP intensive task can be deferred to a child process while the main Node app can continue to process events.

There are 4 ways to launch a child process (all are in "child_process" module):

1) spawn(command, [args], [options])
	Launches a new process and executes the command (the first parameter) with "args"
	Returns a ChildProcess, which is an EventEmitter that emits "exit" and "close" events that can be listened to by the main Node app.

2) exec(command, [options], callback)
	Runs "command" string in a shell
	Callback is invoked on process completion with error, stderr, stdout

3) execfile(file, [args], [options], callback)
	Similar to exec, except "file" is executed directly rather than in a subshell

4) fork(modulePath, [args], [options])
	A special version of "spawn" expecially for creating Node processes
	Adds a "send" function and "message" event to ChildProcess, to facilitate communication between parent and child processes
